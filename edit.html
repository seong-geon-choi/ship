<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>낚시배 목록 편집</title>
    <style>
        /* 기본 스타일 */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            position: relative; /* For absolute positioning of pencil button */
        }
        
        /* 메인 페이지로 버튼 (연필 모양) */
        .pencil-btn {
            position: absolute;
            top: 25px;
            left: 20px;
            background-color: #f39c12; /* Pencil yellow */
            color: white;
            text-decoration: none;
            padding: 8px 15px 8px 30px; /* Increased left padding for shape */
            border-radius: 0 5px 5px 0; /* Rounded right side */
            font-size: 14px;
            transition: background-color 0.3s;
            z-index: 10; /* Ensure it's above other elements */
            clip-path: polygon(0% 50%, 15% 0%, 100% 0%, 100% 100%, 15% 100%); /* Pointed shape */
        }

        .pencil-btn:hover {
            background-color: #e67e22; /* Darker yellow */
        }

        /* 메인 타이틀 스타일 */
        .main-title {
            text-align: center;
            color: #333;
            font-size: 24px;
            margin: 20px 0;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* 상단 컨트롤 영역 */
        .top-controls {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        /* 파일 컨트롤 영역 */
        .file-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        /* 버튼 공통 스타일 (상단 버튼용) */
        .btn {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            min-width: 150px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            transition: background-color 0.3s;
        }
        
        .btn:hover {
            background-color: #45a049;
        }
        
        .btn.secondary {
            background-color: #2196F3;
        }

        .btn.secondary:hover {
            background-color: #1976D2;
        }

        /* 설명 텍스트 스타일 */
        .description {
            color: #666;
            font-size: 14px;
            margin: 10px 0;
            text-align: center;
        }

        /* 테이블 컨테이너 */
        .ship-list {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            overflow-x: auto;
            padding: 20px;
            position: relative; /* For absolute positioning of add button */
        }

        /* 새 항목 추가 아이콘 버튼 */
        .add-icon-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background-color: #3498db;
            color: white;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            font-size: 20px;
            line-height: 32px;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.3s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .add-icon-btn:hover {
            background-color: #2980b9;
        }

        /* 테이블 스타일 */
        table {
            table-layout: fixed; /* Prevent content from changing column widths */
            width: 100%;
            border-collapse: collapse;
            min-width: 1000px;
            margin-top: 10px;
        }
        
        /* 열 너비 조정 */
        th:nth-child(1), td:nth-child(1) { width: 5%; } /* 순번 */
        th:nth-child(2), td:nth-child(2) { width: 10%; } /* 지역명 */
        th:nth-child(3), td:nth-child(3) { width: 10%; } /* 배이름 */
        th:nth-child(4), td:nth-child(4) { width: 25%; } /* 예약사이트URL */
        th:nth-child(5), td:nth-child(5) { width: 7%; } /* URL_TYPE */
        th:nth-child(6), td:nth-child(6) { width: 7%; } /* 보여주기 */
        th:nth-child(7), td:nth-child(7) { width: 16%; } /* 기타메모 */
        th:nth-child(8), td:nth-child(8) { width: 20%; } /* 작업 */

        /* 중앙 정렬이 필요한 열 */
        th:nth-child(1), td:nth-child(1), /* 순번 */
        th:nth-child(5), td:nth-child(5), /* URL_TYPE */
        th:nth-child(6), td:nth-child(6), /* 보여주기 */
        th:nth-child(8), td:nth-child(8) { /* 작업 */
            text-align: center;
        }

        /* 테이블 행 호버 효과 */
        tr:hover td {
            background-color: #f5f5f5;
        }

        /* 테이블 셀 스타일 */
        th, td {
            padding: 8px 10px;
            text-align: left;
            border-bottom: 1px solid #ddd;
            vertical-align: middle;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            background-clip: padding-box;
        }

        /* 메모 컬럼 스타일 */
        td:nth-child(7) {
            position: relative;
        }

        td:nth-child(7) span.view-mode {
            position: relative;
            cursor: default;
            display: block;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* 긴 메모에만 커서 스타일 적용 */
        td:nth-child(7) span.view-mode[data-tooltip] {
            cursor: help;
        }

        /* 입력 필드 스타일 */
        .edit-mode input[type="text"], 
        .edit-mode select {
            width: 100%;
            padding: 6px;
            border: 1px solid #2196F3;
            border-radius: 4px;
            font-size: 14px;
            background-color: #fff;
            box-shadow: 0 0 3px rgba(33, 150, 243, 0.2);
            box-sizing: border-box;
        }

        /* URL과 메모 입력 필드 특별 스타일 */
        td:nth-child(4) input[type="text"], /* URL */
        td:nth-child(7) input[type="text"] { /* 메모 */
            width: 100%;
            white-space: normal;
        }

        /* URL_TYPE과 보여주기 select 박스 스타일 */
        td:nth-child(5) select, /* URL_TYPE */
        td:nth-child(6) select { /* 보여주기 */
            width: 100%;
            text-align: center;
        }

        /* 지역명과 배이름 입력 필드 스타일 */
        td:nth-child(2) input[type="text"], /* 지역명 */
        td:nth-child(3) input[type="text"] { /* 배이름 */
            width: 100%;
        }

        /* 기본 보기 모드 스타일 */
        td span.view-mode {
            display: block;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* 중복된 배 이름 스타일 */
        .duplicate-name {
            background-color: pink !important;
        }

        .edit-mode select {
            cursor: pointer;
            text-align: center; /* Center align select text */
        }
        
        /* 보여주기 열의 select는 중앙 정렬 */
        td:nth-child(6) .edit-mode select {
            margin: 0 auto; /* Center the select box itself if needed */
        }

        /* 테이블 버튼 스타일 */
        .table-btn {
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            width: 60px;
            height: 28px;
            color: white;
            margin-right: 5px;
            transition: background-color 0.3s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            font-weight: normal;
        }

        .edit-btn {
            background-color: #4CAF50;
        }

        .edit-btn:hover {
            background-color: #45a049;
        }
        
        /* 저장 버튼은 파란색 유지 */
        .save-btn {
            background-color: #2196F3 !important; /* 파란색, 우선순위 높임 */
        }
        
        .save-btn:hover {
            background-color: #1976D2 !important; /* 파란색 호버, 우선순위 높임 */
        }

        .delete-btn {
            background-color: #f44336;
        }

        .delete-btn:hover {
            background-color: #da190b;
        }

        /* 작업 열 스타일 */
        .actions {
            white-space: nowrap;
            /* width는 아래 열 너비 설정에서 관리 */
            text-align: center;
            padding: 8px 4px !important;
        }

        /* 드래그 앤 드롭 스타일 */
        tr.dragging {
            opacity: 0.5;
            background-color: #f0f0f0;
        }

        tr.over {
            border-top: 2px solid #4CAF50;
        }

        /* 순번 컬럼 드래그 핸들 스타일 */
        td:first-child {
            cursor: move;
            user-select: none;
            position: relative;
        }

        td:first-child::after {
            content: '⋮⋮';
            position: absolute;
            right: 5px;
            color: #999;
            font-size: 12px;
        }

        /* 상태 메시지 스타일 */
        #status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }

        .success {
            background-color: #dff0d8;
            color: #3c763d;
            border: 1px solid #d6e9c6;
        }

        .error {
            background-color: #f2dede;
            color: #a94442;
            border: 1px solid #ebccd1;
        }

        /* 팝업 메시지 스타일 */
        #popupContainer {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1001; /* Ensure popups are above pencil button */
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }
        .popup-message {
            padding: 15px 25px;
            border-radius: 4px;
            color: white;
            font-size: 14px;
            margin-bottom: 10px;
            animation: slideIn 0.5s ease-out forwards;
            max-width: 300px;
            word-wrap: break-word;
            opacity: 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .popup-message.show {
            opacity: 1;
        }
        .popup-message.success {
            background-color: #4CAF50;
        }
        .popup-message.error {
            background-color: #f44336;
        }

        /* 모달 스타일 */
        .modal {
            display: none; 
            position: fixed; 
            z-index: 1000; 
            left: 0; 
            top: 0; 
            width: 100%; 
            height: 100%; 
            background-color: rgba(0,0,0,0.5);
        }
        .modal-content {
            background-color: #fefefe; 
            margin: 15% auto; 
            padding: 20px; 
            border: 1px solid #888; 
            width: 80%; 
            max-width: 500px; 
            border-radius: 5px;
        }

        /* 애니메이션 */
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* 정렬 가능한 헤더 스타일 */
        th.sortable {
            cursor: pointer;
            position: relative;
            padding-right: 20px;
        }

        th.sortable::after {
            content: '⇅';
            position: absolute;
            right: 5px;
            color: #999;
        }

        th.sortable.asc::after {
            content: '↑';
            color: #333;
        }

        th.sortable.desc::after {
            content: '↓';
            color: #333;
        }

        /* 메모 컬럼 툴팁 스타일 */
        td:nth-child(7) span.view-mode {
            position: relative;
            cursor: default;
        }

        /* 긴 메모에만 커서와 밑줄 스타일 적용 */
        td:nth-child(7) span.view-mode[data-tooltip] {
            cursor: help;
            text-decoration: underline dotted #666;
            text-underline-offset: 2px; /* 밑줄과 텍스트 사이 간격 조정 */
            text-decoration-thickness: 1px; /* 밑줄 두께 조정 */
        }

        .tooltip {
            position: fixed;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            white-space: normal;
            max-width: 300px;
            word-wrap: break-word;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            pointer-events: none;
            display: none;
        }
    </style>
    <link rel="stylesheet" href="./style.css">
</head>
<body>
    <a href="index.html" class="pencil-btn">메인</a>

    <div class="main-title">
        낚시배 목록 편집
    </div>
    
    <div class="top-controls">
        <div class="control-group file-controls">
            <button class="btn" onclick="document.getElementById('fileInput').click()">CSV 파일 불러오기</button>
            <input type="file" id="fileInput" accept=".csv" style="display: none;">
            <button class="btn" onclick="downloadFile()">CSV 파일 다운로드</button>
        </div>

        <div class="description">
            * 드래그 앤 드롭으로 항목의 순서를 변경할 수 있습니다.
        </div>
    </div>

    <div id="githubTokenModal" class="modal">
        <div class="modal-content">
            <h2>GitHub 토큰 설정</h2>
            <p>GitHub Personal Access Token을 입력해주세요. (최초 1회만 입력하시면 됩니다)</p>
            <input type="password" id="githubTokenInput" style="width: 100%; padding: 8px; margin: 10px 0; border: 1px solid #ddd; border-radius: 4px;">
            <button class="btn" onclick="saveToken()" style="margin-top: 10px;">토큰 저장</button>
            <p style="font-size: 0.9em; color: #666; margin-top: 15px;">
                * Token 생성 방법:<br>
                1. GitHub.com → Settings → Developer settings → Personal access tokens → Tokens (classic)<br>
                2. Generate new token (classic) 클릭<br>
                3. repo 권한 체크 후 생성
            </p>
        </div>
    </div>

    <div id="status" class="status"></div>
    
    <div class="ship-list">
        <button class="add-icon-btn" onclick="addNewShip()" title="새 항목 추가">+</button>

        <table id="shipTable">
            <thead>
                <tr>
                    <th>순번</th>
                    <th class="sortable" onclick="sortTable('region')">지역명</th>
                    <th class="sortable" onclick="sortTable('name')">배이름</th>
                    <th>예약사이트URL</th>
                    <th title="1:더피싱, 2:선상24">URL_TYPE</th>
                    <th>보여주기</th>
                    <th>기타메모</th>
                    <th>작업</th>
                </tr>
            </thead>
            <tbody id="shipTableBody"></tbody>
        </table>
    </div>
    
    <div id="popupContainer"></div>
    
    <script>
        let shipData = [];
        let originalData = [];
        let draggedRow = null;
        let currentSort = { field: 'region', direction: 'asc' };

        async function loadCSV() {
            const token = localStorage.getItem('githubToken');
            if (!token) {
                document.getElementById('githubTokenModal').style.display = 'block';
                throw new Error('GitHub 토큰이 필요합니다. 토큰을 입력해주세요.');
            }

            const owner = 'seong-geon-choi';
            const repo = 'ship';
            const path = 'shiplist.csv';
            const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;

            try {
                const response = await fetch(apiUrl, {
                    headers: {
                        'Authorization': `token ${token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });

                if (!response.ok) {
                    if (response.status === 401) {
                        localStorage.removeItem('githubToken');
                        document.getElementById('githubTokenModal').style.display = 'block';
                        throw new Error('GitHub 토큰이 유효하지 않습니다. 새로운 토큰을 입력해주세요.');
                    }
                    throw new Error(`GitHub API 오류: ${response.statusText}`);
                }

                const data = await response.json();
                const decoder = new TextDecoder('utf-8');
                const contentBytes = Uint8Array.from(atob(data.content), c => c.charCodeAt(0));
                const contents = decoder.decode(contentBytes);

                if (!contents) {
                    throw new Error('CSV 파일이 비어있습니다.');
                }

                const lines = contents.split('\n').filter(line => line.trim() !== '');
                if (lines.length < 2) {
                    throw new Error('CSV 파일에 데이터가 없습니다.');
                }

                const headers = lines[0].split(',');
                shipData = lines.slice(1).map(line => {
                    const values = line.split(',');
                    return {
                        id: values[0],
                        region: values[1],
                        name: values[2],
                        url: values[3],
                        urlType: values[4],
                        show: values[5] === 'O',
                        memo: values[6]
                    };
                });
                
                originalData = JSON.parse(JSON.stringify(shipData));
                showPopupMessage('GitHub에서 파일을 성공적으로 로드했습니다.', 'success');
                createTable();
            } catch (error) {
                console.error('CSV 로드 오류:', error);
                showPopupMessage('GitHub에서 파일 로드 중 오류가 발생했습니다: ' + error.message, 'error');
                document.getElementById('shipTableBody').innerHTML = `
                    <tr>
                        <td colspan="8" style="text-align: center; padding: 20px;">
                            <p>GitHub에서 CSV 파일을 불러오지 못했습니다.</p>
                            <p>GitHub 토큰을 확인해주세요.</p>
                        </td>
                    </tr>
                `;
                throw error;
            }
        }

        function handleDragStart(e) {
            // 순번 컬럼이 아닌 경우 드래그 방지
            if (!e.target.matches('td:first-child')) {
                e.preventDefault();
                return;
            }

            draggedRow = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
            draggedRow = null;
        }

        function handleDragOver(e) {
            e.preventDefault();
            return false;
        }

        function handleDragEnter(e) {
            this.classList.add('over');
        }

        function handleDragLeave(e) {
            this.classList.remove('over');
        }

        function handleDrop(e) {
            e.stopPropagation();
            e.preventDefault();
            
            if (draggedRow !== this) {
                const tbody = document.getElementById('shipTableBody');
                const rows = Array.from(tbody.querySelectorAll('tr'));
                const draggedIndex = rows.indexOf(draggedRow);
                const dropIndex = rows.indexOf(this);
                
                if (draggedIndex !== -1 && dropIndex !== -1) {
                    const temp = shipData[draggedIndex];
                    shipData[draggedIndex] = shipData[dropIndex];
                    shipData[dropIndex] = temp;
                    
                    shipData.forEach((ship, index) => {
                        ship.id = (index + 1).toString();
                    });
                    
                    createTable();
                }
            }
            
            this.classList.remove('over');
            return false;
        }

        function createTable() {
            const tbody = document.getElementById('shipTableBody');
            tbody.innerHTML = '';
            
            // 기본적으로 지역명으로 정렬
            shipData.sort((a, b) => a.region.localeCompare(b.region));
            
            // 배 이름 중복 체크를 위한 맵
            const shipNameCount = new Map();
            
            // 먼저 각 배 이름의 출현 횟수를 계산
            shipData.forEach(ship => {
                if (ship.name) {
                    shipNameCount.set(ship.name, (shipNameCount.get(ship.name) || 0) + 1);
                }
            });

            // 툴팁 요소 생성
            let tooltip = document.querySelector('.tooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.className = 'tooltip';
                document.body.appendChild(tooltip);
            }

            shipData.forEach((ship, index) => {
                const tr = document.createElement('tr');
                tr.draggable = false; // 기본적으로 드래그 불가능하게 설정
                
                // 드래그 이벤트 리스너 추가
                tr.addEventListener('dragstart', handleDragStart);
                tr.addEventListener('dragover', handleDragOver);
                tr.addEventListener('drop', handleDrop);
                tr.addEventListener('dragend', handleDragEnd);
                tr.addEventListener('dragenter', handleDragEnter);
                tr.addEventListener('dragleave', handleDragLeave);

                const isDuplicate = shipNameCount.get(ship.name) > 1;
                const nameClass = isDuplicate ? 'duplicate-name' : '';
                
                // 메모 내용이 긴 경우에만 툴팁 속성 추가
                const memoContent = ship.memo || '';
                const memoTooltip = memoContent.length > 20 ? `data-tooltip="${memoContent.replace(/"/g, '&quot;')}"` : '';

                tr.innerHTML = `
                    <td draggable="true" ondragstart="handleDragStart.call(this.parentNode, event)">${index + 1}</td>
                    <td>
                        <span class="view-mode">${ship.region || ''}</span>
                        <input type="text" class="edit-mode" value="${ship.region || ''}" onchange="updateData(${index}, 'region', this.value)" style="display: none;">
                    </td>
                    <td class="${nameClass}">
                        <span class="view-mode">${ship.name || ''}</span>
                        <input type="text" class="edit-mode" value="${ship.name || ''}" onchange="updateData(${index}, 'name', this.value)" style="display: none;">
                    </td>
                    <td>
                        <span class="view-mode">${ship.url || ''}</span>
                        <input type="text" class="edit-mode" value="${ship.url || ''}" onchange="updateData(${index}, 'url', this.value)" style="display: none;">
                    </td>
                    <td>
                        <span class="view-mode">${ship.urlType || ''}</span>
                        <select class="edit-mode" onchange="updateData(${index}, 'urlType', this.value)" style="display: none;">
                            <option value="1" ${ship.urlType === '1' ? 'selected' : ''}>1</option>
                            <option value="2" ${ship.urlType === '2' ? 'selected' : ''}>2</option>
                        </select>
                    </td>
                    <td>
                        <span class="view-mode">${ship.show ? 'O' : 'X'}</span>
                        <select class="edit-mode" onchange="updateData(${index}, 'show', this.value === 'O')" style="display: none;">
                            <option value="O" ${ship.show ? 'selected' : ''}>O</option>
                            <option value="X" ${!ship.show ? 'selected' : ''}>X</option>
                        </select>
                    </td>
                    <td>
                        <span class="view-mode" ${memoTooltip}>${memoContent}</span>
                        <input type="text" class="edit-mode" value="${memoContent}" onchange="updateData(${index}, 'memo', this.value)" style="display: none;">
                    </td>
                    <td class="actions">
                        <button class="table-btn edit-btn" onclick="toggleEditMode(${index})">수정</button>
                        <button class="table-btn save-btn" onclick="saveRow(${index})" style="display: none;">저장</button>
                        <button class="table-btn delete-btn" onclick="deleteShip(${index})">삭제</button>
                    </td>
                `;

                tbody.appendChild(tr);
            });

            // 메모 툴팁 이벤트 핸들러 추가
            document.querySelectorAll('td:nth-child(7) span.view-mode[data-tooltip]').forEach(element => {
                element.addEventListener('mousemove', (e) => {
                    const tooltip = document.querySelector('.tooltip');
                    tooltip.textContent = element.getAttribute('data-tooltip');
                    tooltip.style.display = 'block';
                    
                    // 마우스 커서 위치에 따라 툴팁 위치 조정
                    const x = e.clientX + 10;
                    const y = e.clientY + 10;
                    
                    // 툴팁이 화면 밖으로 나가지 않도록 조정
                    const tooltipRect = tooltip.getBoundingClientRect();
                    const maxX = window.innerWidth - tooltipRect.width - 10;
                    const maxY = window.innerHeight - tooltipRect.height - 10;
                    
                    tooltip.style.left = Math.min(x, maxX) + 'px';
                    tooltip.style.top = Math.min(y, maxY) + 'px';
                });

                element.addEventListener('mouseleave', () => {
                    const tooltip = document.querySelector('.tooltip');
                    tooltip.style.display = 'none';
                });
            });
        }

        function toggleEditMode(index) {
            const tbody = document.getElementById('shipTableBody');
            const row = tbody.children[index];
            if (!row) return;

            const editBtn = row.querySelector('.edit-btn');
            const saveBtn = row.querySelector('.save-btn');
            const viewModes = row.querySelectorAll('.view-mode');
            const editModes = row.querySelectorAll('.edit-mode');

            // 다른 행의 편집 모드를 해제하기 전에 변경사항 저장
            Array.from(tbody.children).forEach((otherRow, i) => {
                if (i !== index) {
                    const otherEditModes = otherRow.querySelectorAll('.edit-mode');
                    const otherViewModes = otherRow.querySelectorAll('.view-mode');
                    const otherEditBtn = otherRow.querySelector('.edit-btn');
                    const otherSaveBtn = otherRow.querySelector('.save-btn');

                    if (otherEditBtn && otherSaveBtn && otherEditBtn.style.display === 'none') {
                        // 각 입력 필드의 현재 값을 저장
                        otherEditModes.forEach((editMode, fieldIndex) => {
                            if (editMode.value !== undefined) {
                                const field = getFieldNameByIndex(fieldIndex);
                                if (field) {
                                    updateData(i, field, editMode.value);
                                }
                            }
                        });

                        otherViewModes.forEach(el => el.style.display = '');
                        otherEditModes.forEach(el => el.style.display = 'none');
                        otherEditBtn.style.display = '';
                        otherSaveBtn.style.display = 'none';
                    }
                }
            });

            // 현재 행의 편집 모드 토글
            const isEditing = editBtn.style.display === 'none';
            viewModes.forEach(el => el.style.display = isEditing ? '' : 'none');
            editModes.forEach(el => el.style.display = isEditing ? 'none' : '');
            editBtn.style.display = isEditing ? '' : 'none';
            saveBtn.style.display = isEditing ? 'none' : '';
        }

        function updateData(index, field, value) {
            // 데이터 업데이트
            if (field === 'show') {
                shipData[index][field] = value;
            } else {
                shipData[index][field] = value;
            }
            
            // 배 이름이 변경된 경우 중복 체크
            if (field === 'name') {
                const tbody = document.getElementById('shipTableBody');
                const rows = tbody.getElementsByTagName('tr');
                
                // 배 이름 중복 체크를 위한 맵
                const shipNameCount = new Map();
                shipData.forEach(ship => {
                    if (ship.name) {
                        shipNameCount.set(ship.name, (shipNameCount.get(ship.name) || 0) + 1);
                    }
                });
                
                // 모든 행의 중복 클래스 초기화
                Array.from(rows).forEach((row, i) => {
                    const nameCell = row.children[2];
                    nameCell.classList.remove('duplicate-name');
                    
                    // 현재 행의 배 이름이 중복되는 경우 클래스 추가
                    if (shipData[i].name && shipNameCount.get(shipData[i].name) > 1) {
                        nameCell.classList.add('duplicate-name');
                    }
                    
                    // 현재 행의 view-mode span 업데이트
                    const viewMode = nameCell.querySelector('.view-mode');
                    if (viewMode) {
                        viewMode.textContent = shipData[i].name || '';
                    }
                });
            }
        }

        async function saveRow(index) {
            try {
                // 필수값 체크
                if (!shipData[index].region || !shipData[index].name) {
                    showPopupMessage('지역명과 배이름은 필수 입력값입니다.', 'error');
                    return;
                }

                // 현재 데이터 백업
                const currentData = JSON.parse(JSON.stringify(shipData));
                
                await saveToGitHub();
                showPopupMessage('변경사항이 저장되었습니다.', 'success');
                
                // 저장 성공 시 백업 데이터를 원본 데이터로 설정
                originalData = JSON.parse(JSON.stringify(currentData));
                
                // 편집 모드 종료
                toggleEditMode(index);
                
                // 화면 갱신
                const row = document.getElementById('shipTableBody').children[index];
                if (row) {
                    // 각 셀의 view-mode span 업데이트
                    const viewModes = row.querySelectorAll('.view-mode');
                    const ship = shipData[index];
                    
                    viewModes[0].textContent = ship.region || '';
                    viewModes[1].textContent = ship.name || '';
                    viewModes[2].textContent = ship.url || '';
                    viewModes[3].textContent = ship.urlType || '';
                    viewModes[4].textContent = ship.show ? 'O' : 'X';
                    viewModes[5].textContent = ship.memo || '';
                    
                    // 메모 필드의 툴팁 업데이트
                    const memoSpan = viewModes[5];
                    if (ship.memo && ship.memo.length > 20) {
                        memoSpan.setAttribute('data-tooltip', ship.memo);
                        memoSpan.style.cursor = 'help';
                    } else {
                        memoSpan.removeAttribute('data-tooltip');
                        memoSpan.style.cursor = 'default';
                    }
                }
            } catch (error) {
                console.error('저장 실패:', error);
                showPopupMessage('저장에 실패했습니다: ' + error.message, 'error');
                
                // 저장 실패 시 원래 데이터로 복원
                shipData = JSON.parse(JSON.stringify(originalData));
                createTable();
            }
        }

        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const contents = e.target.result;
                        const lines = contents.split('\n');
                        const headers = lines[0].split(',');
                        
                        shipData = lines.slice(1).map(line => {
                            const values = line.split(',');
                            return {
                                id: values[0],
                                region: values[1],
                                name: values[2],
                                url: values[3],
                                urlType: values[4],
                                show: values[5] === 'O',
                                memo: values[6]
                            };
                        });
                        
                        originalData = JSON.parse(JSON.stringify(shipData));
                        
                        showStatus('파일이 성공적으로 로드되었습니다.', 'success');
                        createTable();
                    } catch (error) {
                        showStatus('파일 로드 중 오류가 발생했습니다: ' + error.message, 'error');
                    }
                };
                reader.readAsText(file);
            }
        });

        window.onload = async function() {
            try {
                await loadCSV();
            } catch (error) {
                console.error('CSV 로드 중 오류:', error);
                if (!localStorage.getItem('githubToken')) {
                    document.getElementById('githubTokenModal').style.display = 'block';
                }
            }
        };

        function downloadFile() {
            if (shipData.length === 0) {
                showStatus('저장할 데이터가 없습니다.', 'error');
                return;
            }

            const headers = ['순번', '지역명', '배이름', '예약사이트URL', 'URL_TYPE', '보여주기', '기타메모'];
            const csvContent = [
                headers.join(','),
                ...shipData.map(ship => [
                    ship.id,
                    ship.region,
                    ship.name,
                    ship.url,
                    ship.urlType,
                    ship.show ? 'O' : 'X',
                    ship.memo || ''
                ].join(','))
            ].join('\n');

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            link.setAttribute('href', url);
            link.setAttribute('download', 'shiplist.csv');
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            URL.revokeObjectURL(url);
            
            showStatus('파일이 성공적으로 저장되었습니다.', 'success');
        }
        
        function addNewShip() {
            const newId = "1";
            // 기존 항목들의 ID 증가
            shipData.forEach(ship => {
                ship.id = (parseInt(ship.id) + 1).toString();
            });
            
            // 새 항목 추가
            const newShip = {
                id: newId,
                region: '',
                name: '',
                url: '',
                urlType: '1',
                show: true,
                memo: ''
            };
            
            // 배열 맨 앞에 새 항목 추가
            shipData.unshift(newShip);
            
            // 테이블 다시 그리기
            createTable();
            
            // 새로 추가된 항목의 편집 모드 활성화
            setTimeout(() => {
                toggleEditMode(0);
            }, 100);
        }
        
        async function deleteShip(index) {
            if (confirm('정말로 이 낚시배를 삭제하시겠습니까?')) {
                const deletedShip = { ...shipData[index] };
                const originalIndex = index;
                
                shipData.splice(index, 1);
                
                shipData.forEach((ship, i) => {
                    ship.id = (i + 1).toString();
                });
                
                createTable();

                try {
                    const headers = ['순번', '지역명', '배이름', '예약사이트URL', 'URL_TYPE', '보여주기', '기타메모'];
                    const csvContent = [
                        headers.join(','),
                        ...shipData.map(ship => [
                            ship.id,
                            ship.region,
                            ship.name,
                            ship.url,
                            ship.urlType,
                            ship.show ? 'O' : 'X',
                            ship.memo || ''
                        ].join(','))
                    ].join('\n');

                    await updateFileInGitHub(csvContent);
                    
                    showPopupMessage(`'${deletedShip.name}' 항목이 삭제되었습니다.`, 'success');
                } catch (error) {
                    shipData.splice(originalIndex, 0, deletedShip);
                    shipData.forEach((ship, i) => {
                        ship.id = (i + 1).toString();
                    });
                    createTable();
                    showPopupMessage('저장 중 오류가 발생했습니다. 삭제가 취소되었습니다.', 'error');
                }
            }
        }

        function showPopupMessage(message, type) {
            const popupContainer = document.getElementById('popupContainer');
            const popup = document.createElement('div');
            popup.className = `popup-message ${type}`;
            popup.textContent = message;
            
            popupContainer.appendChild(popup);
            
            setTimeout(() => {
                popup.classList.add('show');
            }, 10);

            setTimeout(() => {
                popup.style.opacity = '0';
                popup.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (popup.parentNode === popupContainer) {
                         popupContainer.removeChild(popup);
                    }
                }, 500);
            }, 3000);
        }

        function showStatus(message, type) {
            showPopupMessage(message, type);
        }

        async function saveToGitHub() {
            const token = localStorage.getItem('githubToken');
            if (!token) {
                document.getElementById('githubTokenModal').style.display = 'block';
                return;
            }

            if (shipData.length === 0) {
                showPopupMessage('저장할 데이터가 없습니다.', 'error');
                return;
            }

            try {
                const headers = ['순번', '지역명', '배이름', '예약사이트URL', 'URL_TYPE', '보여주기', '기타메모'];
                const csvContent = [
                    headers.join(','),
                    ...shipData.map(ship => [
                        ship.id,
                        ship.region,
                        ship.name,
                        ship.url,
                        ship.urlType,
                        ship.show ? 'O' : 'X',
                        ship.memo || ''
                    ].join(','))
                ].join('\n');

                await updateFileInGitHub(csvContent);
                showPopupMessage('GitHub에 성공적으로 저장되었습니다.', 'success');
            } catch (error) {
                console.error('GitHub 저장 오류:', error);
                showPopupMessage('GitHub 저장 중 오류가 발생했습니다: ' + error.message, 'error');
            }
        }

        function saveToken() {
            const token = document.getElementById('githubTokenInput').value.trim();
            if (token) {
                localStorage.setItem('githubToken', token);
                document.getElementById('githubTokenModal').style.display = 'none';
                showPopupMessage('GitHub 토큰이 저장되었습니다. 이제 자동으로 저장됩니다.', 'success');
                loadCSV();
            } else {
                showPopupMessage('유효한 GitHub 토큰을 입력해주세요.', 'error');
            }
        }

        async function updateFileInGitHub(content) {
            const token = localStorage.getItem('githubToken');
            if (!token) {
                document.getElementById('githubTokenModal').style.display = 'block';
                throw new Error('GitHub 토큰이 필요합니다. 토큰을 입력해주세요.');
            }

            const owner = 'seong-geon-choi';
            const repo = 'ship';
            const path = 'shiplist.csv';

            const getCurrentFileUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;
            const getCurrentFileResponse = await fetch(getCurrentFileUrl, {
                headers: {
                    'Authorization': `token ${token}`,
                    'Accept': 'application/vnd.github.v3+json'
                }
            });

            if (!getCurrentFileResponse.ok) {
                if (getCurrentFileResponse.status === 401) {
                    localStorage.removeItem('githubToken');
                    document.getElementById('githubTokenModal').style.display = 'block';
                    throw new Error('GitHub 토큰이 유효하지 않습니다. 새로운 토큰을 입력해주세요.');
                }
                throw new Error(`GitHub API 오류: ${getCurrentFileResponse.statusText}`);
            }

            const currentFile = await getCurrentFileResponse.json();

            const updateFileUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;
            
            const encoder = new TextEncoder();
            const contentBytes = encoder.encode(content);
            const contentBase64 = btoa(String.fromCharCode(...contentBytes));
            
            const updateFileResponse = await fetch(updateFileUrl, {
                method: 'PUT',
                headers: {
                    'Authorization': `token ${token}`,
                    'Accept': 'application/vnd.github.v3+json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    message: 'Update ship list',
                    content: contentBase64,
                    sha: currentFile.sha
                })
            });

            if (!updateFileResponse.ok) {
                const errorText = await updateFileResponse.text();
                console.error('GitHub API Error Response:', errorText);
                throw new Error(`GitHub API 오류: ${updateFileResponse.statusText}`);
            }

            return await updateFileResponse.json();
        }

        function sortTable(field) {
            const thead = document.querySelector('#shipTable thead tr');
            const headers = thead.querySelectorAll('th');
            
            // 이전 정렬 표시 제거
            headers.forEach(header => {
                header.classList.remove('asc', 'desc');
            });
            
            // 정렬 방향 결정
            if (currentSort.field === field) {
                currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                currentSort.field = field;
                currentSort.direction = 'asc';
            }
            
            // 정렬 실행
            shipData.sort((a, b) => {
                let comparison = 0;
                if (a[field] && b[field]) {
                    comparison = a[field].localeCompare(b[field]);
                } else if (!a[field] && b[field]) {
                    comparison = 1;
                } else if (a[field] && !b[field]) {
                    comparison = -1;
                }
                return currentSort.direction === 'asc' ? comparison : -comparison;
            });
            
            // 정렬 표시 업데이트
            const header = Array.from(headers).find(h => h.textContent.includes(field === 'region' ? '지역명' : '배이름'));
            if (header) {
                header.classList.add(currentSort.direction);
            }
            
            // 순번 재할당
            shipData.forEach((ship, index) => {
                ship.id = (index + 1).toString();
            });
            
            createTable();
        }

        // 필드 인덱스를 필드 이름으로 변환하는 헬퍼 함수
        function getFieldNameByIndex(index) {
            const fields = ['region', 'name', 'url', 'urlType', 'show', 'memo'];
            return fields[index];
        }
    </script>
</body>
</html>